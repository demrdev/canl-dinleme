<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#667eea">
    <meta name="description" content="Gelişmiş canlı dinleme ve ses odaklama sistemi. AI destekli ses izolasyonu, çoklu mod desteği, profesyonel ses amplifikasyonu.">
    <title>Ultra Advanced Sound Detection & AI Analysis System</title>
    <link rel="manifest" href="manifest.json">
    <script src="advanced-audio-processor.js"></script>
    <script src="heartbeat-demo.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        :root {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
            --dark-bg: #1a1a2e;
            --card-bg: rgba(255, 255, 255, 0.98);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            min-height: 100vh;
            min-height: -webkit-fill-available;
            padding: 10px;
            overflow-x: hidden;
        }
        
        .container {
            background: var(--card-bg);
            border-radius: 24px;
            padding: 20px;
            max-width: 600px;
            margin: 0 auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.5s ease;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Header */
        .header {
            text-align: center;
            margin-bottom: 25px;
        }
        
        h1 {
            font-size: 26px;
            color: #1a1a1a;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-weight: 700;
        }
        
        .subtitle {
            color: #6b7280;
            font-size: 14px;
        }
        
        .live-badge {
            display: inline-block;
            background: var(--error-color);
            color: white;
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: bold;
            animation: pulse 2s infinite;
            text-transform: uppercase;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Quick Start Section */
        .quick-start {
            background: linear-gradient(135deg, var(--success-color) 0%, #059669 100%);
            color: white;
            padding: 20px;
            border-radius: 16px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 8px 20px rgba(16, 185, 129, 0.3);
        }
        
        .quick-start h2 {
            font-size: 18px;
            margin-bottom: 12px;
        }
        
        .big-button {
            background: white;
            color: #059669;
            border: none;
            padding: 16px;
            border-radius: 12px;
            font-size: 17px;
            font-weight: bold;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .big-button:active {
            transform: scale(0.98);
        }
        
        .big-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        /* Mode Selection Tabs */
        .mode-tabs {
            display: flex;
            background: #f3f4f6;
            border-radius: 12px;
            padding: 4px;
            margin-bottom: 20px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .mode-tab {
            flex: 1;
            min-width: 80px;
            padding: 10px 12px;
            border: none;
            background: transparent;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #6b7280;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .mode-tab.active {
            background: white;
            color: var(--primary-color);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .mode-icon {
            font-size: 18px;
        }
        
        .mode-name {
            font-size: 11px;
        }
        
        /* Advanced Features Panel */
        .advanced-panel {
            background: #f9fafb;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }
        
        .advanced-panel.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 15px;
        }
        
        .feature-card {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .feature-card.active {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
        }
        
        .feature-card:active {
            transform: scale(0.98);
        }
        
        .feature-icon {
            font-size: 24px;
            margin-bottom: 6px;
        }
        
        .feature-name {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 4px;
        }
        
        .feature-desc {
            font-size: 11px;
            color: #9ca3af;
            line-height: 1.3;
        }
        
        /* Control Section */
        .control-section {
            background: #f3f4f6;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .control-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .control-btn {
            padding: 14px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }
        
        .control-btn:active:not(:disabled) {
            transform: scale(0.95);
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .start-btn {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            grid-column: span 2;
        }
        
        .stop-btn {
            background: var(--error-color);
        }
        
        .mute-btn {
            background: var(--warning-color);
        }
        
        /* Volume Controls */
        .volume-section {
            background: white;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .volume-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .volume-label {
            font-weight: 600;
            color: #374151;
            font-size: 15px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .volume-value {
            font-size: 20px;
            font-weight: bold;
            color: var(--primary-color);
            min-width: 45px;
            text-align: right;
        }
        
        .slider-container {
            position: relative;
        }
        
        .volume-slider {
            width: 100%;
            height: 36px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            outline: none;
            cursor: pointer;
        }
        
        .volume-slider::-webkit-slider-track {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 28px;
            height: 28px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            margin-top: -10px;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
            transition: all 0.2s;
        }
        
        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        /* Advanced Controls */
        .advanced-controls {
            display: grid;
            gap: 12px;
            margin-top: 15px;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .control-row:last-child {
            border-bottom: none;
        }
        
        .control-label {
            font-size: 14px;
            color: #4b5563;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .control-info {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 2px;
        }
        
        .toggle-switch {
            position: relative;
            width: 48px;
            height: 26px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #cbd5e1;
            transition: .3s;
            border-radius: 26px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }
        
        /* Visualizer */
        .visualizer-section {
            background: #1e293b;
            border-radius: 16px;
            padding: 15px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .visualizer-header {
            color: white;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.9;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .frequency-display {
            font-size: 11px;
            color: #94a3b8;
            font-weight: normal;
        }
        
        canvas {
            width: 100%;
            height: 120px;
            border-radius: 8px;
        }
        
        /* Real-time Indicators */
        .indicators-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .indicator-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 12px;
            text-align: center;
        }
        
        .indicator-value {
            font-size: 20px;
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 4px;
        }
        
        .indicator-label {
            font-size: 11px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Status Bar */
        .status-bar {
            padding: 14px;
            border-radius: 10px;
            text-align: center;
            font-weight: 500;
            margin-bottom: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.3s;
        }
        
        .status-idle {
            background: #f3f4f6;
            color: #6b7280;
        }
        
        .status-active {
            background: #dcfce7;
            color: #15803d;
        }
        
        .status-error {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .status-warning {
            background: #fef3c7;
            color: #92400e;
        }
        
        /* Permission Card */
        .permission-card {
            background: #fef3c7;
            border: 2px solid var(--warning-color);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            display: none;
        }
        
        .permission-card.show {
            display: block;
        }
        
        .permission-card.success {
            background: #dcfce7;
            border-color: var(--success-color);
        }
        
        .permission-card.error {
            background: #fee2e2;
            border-color: var(--error-color);
        }
        
        .permission-title {
            font-weight: bold;
            font-size: 15px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Help Section */
        .help-section {
            background: #eff6ff;
            border-radius: 16px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .help-title {
            font-weight: bold;
            color: #1e40af;
            margin-bottom: 12px;
            font-size: 15px;
        }
        
        .help-list {
            list-style: none;
        }
        
        .help-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 10px;
            color: #1e40af;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .help-icon {
            background: #3b82f6;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            margin-right: 10px;
            flex-shrink: 0;
        }
        
        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        
        .loading-overlay.show {
            display: flex;
        }
        
        .loading-content {
            background: white;
            border-radius: 16px;
            padding: 30px;
            text-align: center;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #e5e7eb;
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* AI Category Styles */
        .ai-category {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px;
            text-align: center;
            position: relative;
            transition: all 0.3s;
        }
        
        .ai-category.active {
            background: rgba(139, 92, 246, 0.2);
            border-color: #a78bfa;
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
        }
        
        .confidence-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, #10b981, #3b82f6, #8b5cf6);
            border-radius: 3px;
            transition: width 0.3s;
        }
        
        /* Mobile Optimizations */
        @media (max-width: 500px) {
            .container {
                padding: 15px;
                border-radius: 20px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            .mode-tabs {
                gap: 5px;
            }
            
            .feature-grid {
                grid-template-columns: 1fr;
            }
            
            .indicators-grid {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .control-buttons {
                grid-template-columns: 1fr;
            }
            
            .start-btn {
                grid-column: span 1;
            }
        }
        
        /* Dark Mode Support */
        @media (prefers-color-scheme: dark) {
            :root {
                --card-bg: rgba(30, 30, 60, 0.98);
            }
            
            body {
                background: linear-gradient(135deg, #1a1a2e 0%, #0f0f23 100%);
            }
            
            .container {
                background: var(--card-bg);
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            h1, .subtitle {
                color: #ffffff;
            }
            
            .mode-tab {
                color: #94a3b8;
            }
            
            .mode-tab.active {
                background: rgba(102, 126, 234, 0.2);
                color: #ffffff;
            }
            
            .feature-card {
                background: rgba(255, 255, 255, 0.05);
                border-color: rgba(255, 255, 255, 0.1);
            }
            
            .feature-name {
                color: #e5e7eb;
            }
            
            .volume-section {
                background: rgba(255, 255, 255, 0.05);
            }
            
            .volume-label {
                color: #e5e7eb;
            }
            
            .indicator-card {
                background: rgba(255, 255, 255, 0.05);
                border-color: rgba(255, 255, 255, 0.1);
            }
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div>Sistem hazırlanıyor...</div>
        </div>
    </div>
    
    <div class="container">
        <div class="header">
            <h1>
                <span>🎧</span>
                <span>Canlı Dinleme Pro</span>
                <span class="live-badge" id="liveBadge" style="display: none;">CANLI</span>
            </h1>
            <p class="subtitle">Gelişmiş ses odaklama ve amplifikasyon sistemi</p>
        </div>
        
        <div class="quick-start">
            <h2>🚀 Hızlı Başlangıç</h2>
            <button class="big-button" id="quickStartBtn" onclick="quickStart()">
                <span>🎤</span>
                <span>Hemen Başla</span>
            </button>
        </div>
        
        <div class="permission-card" id="permissionCard">
            <div class="permission-title">
                <span>⚠️</span>
                <span>Mikrofon İzni</span>
            </div>
            <div id="permissionText">Mikrofon erişimi bekleniyor...</div>
        </div>
        
        <!-- Mode Selection -->
        <div class="mode-tabs">
            <button class="mode-tab active" data-mode="normal" onclick="setMode('normal')">
                <span class="mode-icon">🎧</span>
                <span class="mode-name">Normal</span>
            </button>
            <button class="mode-tab" data-mode="voice" onclick="setMode('voice')">
                <span class="mode-icon">🗣️</span>
                <span class="mode-name">Konuşma</span>
            </button>
            <button class="mode-tab" data-mode="meeting" onclick="setMode('meeting')">
                <span class="mode-icon">👥</span>
                <span class="mode-name">Toplantı</span>
            </button>
            <button class="mode-tab" data-mode="outdoor" onclick="setMode('outdoor')">
                <span class="mode-icon">🌲</span>
                <span class="mode-name">Dış Mekan</span>
            </button>
            <button class="mode-tab" data-mode="music" onclick="setMode('music')">
                <span class="mode-icon">🎵</span>
                <span class="mode-name">Müzik</span>
            </button>
            <button class="mode-tab" data-mode="elderly" onclick="setMode('elderly')">
                <span class="mode-icon">👴</span>
                <span class="mode-name">Yaşlı</span>
            </button>
            <button class="mode-tab" data-mode="medical" onclick="setMode('medical')">
                <span class="mode-icon">❤️</span>
                <span class="mode-name">Kalp Demo</span>
            </button>
        </div>
        
        <!-- Advanced Features Panel -->
        <div class="advanced-panel" id="advancedPanel">
            <h3 style="margin-bottom: 10px; color: #1f2937;">🎯 Ses Odaklama Özellikleri</h3>
            <div class="feature-grid">
                <div class="feature-card" id="voiceIsolation" onclick="toggleFeature('voiceIsolation')">
                    <div class="feature-icon">🎯</div>
                    <div class="feature-name">Ses İzolasyonu</div>
                    <div class="feature-desc">İnsan sesine odaklan</div>
                </div>
                <div class="feature-card" id="noiseReduction" onclick="toggleFeature('noiseReduction')">
                    <div class="feature-icon">🔇</div>
                    <div class="feature-name">Gürültü Azaltma</div>
                    <div class="feature-desc">Arka plan seslerini azalt</div>
                </div>
                <div class="feature-card" id="speechEnhance" onclick="toggleFeature('speechEnhance')">
                    <div class="feature-icon">💬</div>
                    <div class="feature-name">Konuşma Netleştirme</div>
                    <div class="feature-desc">Konuşmayı belirginleştir</div>
                </div>
                <div class="feature-card" id="directionFocus" onclick="toggleFeature('directionFocus')">
                    <div class="feature-icon">🧭</div>
                    <div class="feature-name">Yön Odaklama</div>
                    <div class="feature-desc">Belirli yöne odaklan</div>
                </div>
            </div>
        </div>
        
        <!-- Medical Demo Warning -->
        <div id="medicalWarning" style="display: none; background: linear-gradient(135deg, #ef4444, #dc2626); border-radius: 16px; padding: 20px; margin-bottom: 20px; color: white; border: 2px solid #b91c1c;">
            <h3 style="font-size: 18px; margin-bottom: 12px;">⚠️ ÖNEMLİ UYARI - EĞİTSEL DEMO</h3>
            <p style="font-size: 14px; line-height: 1.6; margin-bottom: 10px;">
                <strong>BU SADECE EĞİTSEL AMAÇLI BİR TEKNİK DEMODUR!</strong><br>
                • Gerçek tıbbi tanı veya izleme için KULLANILAMAZ<br>
                • Bebek kalp atışı kontrolü için mutlaka doktorunuza başvurun<br>
                • Bu sadece ses işleme teknolojisinin yeteneklerini gösterir<br>
                • Tıbbi amaçlı kullanım hayati tehlike oluşturabilir
            </p>
            <button onclick="acceptMedicalDemo()" style="background: white; color: #dc2626; border: none; padding: 10px 20px; border-radius: 8px; font-weight: bold; cursor: pointer;">
                Anladım, Sadece Demo Olarak Kullanacağım
            </button>
        </div>
        
        <!-- Heartbeat Demo Display -->
        <div id="heartbeatDisplay" style="display: none; background: linear-gradient(135deg, #1e293b, #0f172a); border-radius: 16px; padding: 20px; margin-bottom: 20px; border: 1px solid rgba(239, 68, 68, 0.3);">
            <h3 style="color: #fca5a5; margin-bottom: 15px; font-size: 16px; text-transform: uppercase; letter-spacing: 1px;">
                ❤️ Kalp Atışı Ritim Analizi (Eğitsel Demo)
            </h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div style="background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 15px; text-align: center;">
                    <div style="font-size: 48px; font-weight: bold; color: #10b981;" id="bpmDisplay">--</div>
                    <div style="font-size: 14px; color: #94a3b8; margin-top: 5px;">BPM (Demo)</div>
                    <div style="font-size: 12px; color: #f59e0b; margin-top: 10px;" id="bpmType">Bekliyor...</div>
                </div>
                <div style="background: rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 15px; text-align: center;">
                    <div style="font-size: 48px; font-weight: bold; color: #3b82f6;" id="confidenceDisplay">0%</div>
                    <div style="font-size: 14px; color: #94a3b8; margin-top: 5px;">Sinyal Kalitesi</div>
                    <div style="font-size: 12px; color: #ef4444; margin-top: 10px;">Tıbbi Değil</div>
                </div>
            </div>
            <canvas id="heartbeatWaveform" style="width: 100%; height: 150px; margin-top: 15px; border-radius: 8px; background: #0f172a;"></canvas>
            <div style="margin-top: 15px; padding: 10px; background: rgba(239, 68, 68, 0.1); border-radius: 8px; border: 1px solid rgba(239, 68, 68, 0.3);">
                <strong style="color: #fca5a5; font-size: 12px;">🔴 DEMO UYARISI:</strong>
                <span style="color: #fca5a5; font-size: 11px;">Bu sadece eğitim amaçlı teknik bir gösterimdir. Gerçek kalp atışı tespiti için profesyonel tıbbi cihazlar gereklidir.</span>
            </div>
        </div>
        
        <!-- AI Sound Classification Display -->
        <div style="background: linear-gradient(135deg, #1e293b, #0f172a); border-radius: 16px; padding: 15px; margin-bottom: 20px; border: 1px solid rgba(139, 92, 246, 0.3);">
            <h3 style="color: #a78bfa; margin-bottom: 12px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">🤖 AI Ses Analizi</h3>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;" id="aiCategories">
                <div class="ai-category" data-category="human">
                    <div style="font-size: 20px;">👤</div>
                    <div style="font-size: 11px;">İnsan</div>
                    <div class="confidence-bar" style="width: 0%"></div>
                </div>
                <div class="ai-category" data-category="animal">
                    <div style="font-size: 20px;">🐾</div>
                    <div style="font-size: 11px;">Hayvan</div>
                    <div class="confidence-bar" style="width: 0%"></div>
                </div>
                <div class="ai-category" data-category="vehicle">
                    <div style="font-size: 20px;">🚗</div>
                    <div style="font-size: 11px;">Araç</div>
                    <div class="confidence-bar" style="width: 0%"></div>
                </div>
                <div class="ai-category" data-category="nature">
                    <div style="font-size: 20px;">🌿</div>
                    <div style="font-size: 11px;">Doğa</div>
                    <div class="confidence-bar" style="width: 0%"></div>
                </div>
                <div class="ai-category" data-category="music">
                    <div style="font-size: 20px;">🎵</div>
                    <div style="font-size: 11px;">Müzik</div>
                    <div class="confidence-bar" style="width: 0%"></div>
                </div>
                <div class="ai-category" data-category="emergency">
                    <div style="font-size: 20px;">🚨</div>
                    <div style="font-size: 11px;">Acil</div>
                    <div class="confidence-bar" style="width: 0%"></div>
                </div>
                <div class="ai-category" data-category="mechanical">
                    <div style="font-size: 20px;">⚙️</div>
                    <div style="font-size: 11px;">Mekanik</div>
                    <div class="confidence-bar" style="width: 0%"></div>
                </div>
                <div class="ai-category" data-category="electronic">
                    <div style="font-size: 20px;">📱</div>
                    <div style="font-size: 11px;">Elektronik</div>
                    <div class="confidence-bar" style="width: 0%"></div>
                </div>
            </div>
        </div>
        
        <!-- Detection Mode Selector -->
        <div style="background: #f3f4f6; border-radius: 12px; padding: 12px; margin-bottom: 20px;">
            <div style="font-size: 13px; font-weight: 600; margin-bottom: 10px; color: #374151;">🎯 Algılama Modu</div>
            <div style="display: flex; gap: 8px; overflow-x: auto;">
                <button class="detection-mode-btn active" data-mode="near" onclick="setDetectionMode('near')" style="padding: 8px 12px; border: none; border-radius: 8px; background: #10b981; color: white; font-size: 12px; cursor: pointer;">
                    🎯 Yakın
                </button>
                <button class="detection-mode-btn" data-mode="medium" onclick="setDetectionMode('medium')" style="padding: 8px 12px; border: none; border-radius: 8px; background: #e5e7eb; color: #374151; font-size: 12px; cursor: pointer;">
                    📡 Orta
                </button>
                <button class="detection-mode-btn" data-mode="far" onclick="setDetectionMode('far')" style="padding: 8px 12px; border: none; border-radius: 8px; background: #e5e7eb; color: #374151; font-size: 12px; cursor: pointer;">
                    🛰️ Uzak
                </button>
                <button class="detection-mode-btn" data-mode="all" onclick="setDetectionMode('all')" style="padding: 8px 12px; border: none; border-radius: 8px; background: #e5e7eb; color: #374151; font-size: 12px; cursor: pointer;">
                    🌐 Tümü
                </button>
                <button class="detection-mode-btn" data-mode="ai" onclick="setDetectionMode('ai')" style="padding: 8px 12px; border: none; border-radius: 8px; background: #e5e7eb; color: #374151; font-size: 12px; cursor: pointer;">
                    🤖 AI
                </button>
            </div>
        </div>
        
        <!-- Real-time Indicators Enhanced -->
        <div class="indicators-grid" style="grid-template-columns: repeat(5, 1fr);">
            <div class="indicator-card">
                <div class="indicator-value" id="clarityValue">0%</div>
                <div class="indicator-label">Netlik</div>
            </div>
            <div class="indicator-card">
                <div class="indicator-value" id="distanceValue">0m</div>
                <div class="indicator-label">Mesafe</div>
            </div>
            <div class="indicator-card">
                <div class="indicator-value" id="directionValue">0°</div>
                <div class="indicator-label">Yön</div>
            </div>
            <div class="indicator-card">
                <div class="indicator-value" id="gainValue">1x</div>
                <div class="indicator-label">Kazanç</div>
            </div>
            <div class="indicator-card">
                <div class="indicator-value" id="noiseValue">0dB</div>
                <div class="indicator-label">Gürültü</div>
            </div>
        </div>
        
        <div class="status-bar status-idle" id="statusBar">
            <span>🔌</span>
            <span>Sistem hazır - Başlat butonuna tıklayın</span>
        </div>
        
        <!-- Control Section -->
        <div class="control-section">
            <div class="control-buttons">
                <button class="control-btn start-btn" id="startBtn" onclick="startListening()" disabled>
                    <span>▶️</span>
                    <span>Dinlemeyi Başlat</span>
                </button>
                <button class="control-btn stop-btn" id="stopBtn" onclick="stopListening()" disabled>
                    <span>⏹️</span>
                    <span>Durdur</span>
                </button>
                <button class="control-btn mute-btn" id="muteBtn" onclick="toggleMute()" disabled>
                    <span>🔇</span>
                    <span>Sessiz</span>
                </button>
            </div>
            
            <!-- Volume Control -->
            <div class="volume-section">
                <div class="volume-header">
                    <span class="volume-label">
                        <span>🔊</span>
                        <span>Ses Güçlendirme</span>
                    </span>
                    <span class="volume-value" id="volumeValue">5x</span>
                </div>
                <div class="slider-container">
                    <input type="range" class="volume-slider" id="volumeSlider" 
                           min="1" max="500" value="10" step="1"
                           oninput="updateVolume(this.value)">
                </div>
            </div>
            
            <!-- Advanced Controls -->
            <div class="advanced-controls">
                <div class="control-row">
                    <div>
                        <div class="control-label">
                            <span>🎚️</span>
                            <span>Dinamik Sıkıştırma</span>
                        </div>
                        <div class="control-info">Ses seviyesini dengeler</div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="compressorToggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <div class="control-row">
                    <div>
                        <div class="control-label">
                            <span>✨</span>
                            <span>Frekans Zenginleştirme</span>
                        </div>
                        <div class="control-info">Ses netliğini artırır</div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="enhancerToggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <div class="control-row">
                    <div>
                        <div class="control-label">
                            <span>⚡</span>
                            <span>Düşük Gecikme</span>
                        </div>
                        <div class="control-info">Minimum gecikme (~10ms)</div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="lowLatencyToggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <div class="control-row">
                    <div>
                        <div class="control-label">
                            <span>🔋</span>
                            <span>Batarya Tasarrufu</span>
                        </div>
                        <div class="control-info">İşlem gücünü optimize eder</div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="batterySaverToggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
        </div>
        
        <!-- Visualizer -->
        <div class="visualizer-section">
            <div class="visualizer-header">
                <span>Ses Spektrumu</span>
                <span class="frequency-display" id="frequencyDisplay">20Hz - 20kHz</span>
            </div>
            <canvas id="visualizer"></canvas>
        </div>
        
        <!-- Advanced Visualizations -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
            <!-- Spectrogram -->
            <div style="background: #1e293b; border-radius: 12px; padding: 15px;">
                <div style="color: white; font-size: 13px; font-weight: 600; margin-bottom: 10px; text-transform: uppercase;">
                    📊 Spektrogram (Zaman-Frekans)
                </div>
                <canvas id="spectrogram" style="width: 100%; height: 150px; border-radius: 8px; background: #0f172a;"></canvas>
            </div>
            
            <!-- 3D Sound Map -->
            <div style="background: #1e293b; border-radius: 12px; padding: 15px;">
                <div style="color: white; font-size: 13px; font-weight: 600; margin-bottom: 10px; text-transform: uppercase;">
                    🧭 3D Ses Haritası
                </div>
                <canvas id="soundMap3D" style="width: 100%; height: 150px; border-radius: 8px; background: #0f172a;"></canvas>
            </div>
        </div>
        
        <!-- Help Section -->
        <div class="help-section">
            <div class="help-title">📚 Kullanım Kılavuzu</div>
            <ul class="help-list">
                <li class="help-item">
                    <span class="help-icon">1</span>
                    <span><strong>Kulaklık takın:</strong> Geri beslemeyi önlemek için gerekli</span>
                </li>
                <li class="help-item">
                    <span class="help-icon">2</span>
                    <span><strong>Mod seçin:</strong> Kullanım amacınıza uygun modu seçin</span>
                </li>
                <li class="help-item">
                    <span class="help-icon">3</span>
                    <span><strong>Özelleştirin:</strong> Ses odaklama özelliklerini ayarlayın</span>
                </li>
                <li class="help-item">
                    <span class="help-icon">4</span>
                    <span><strong>Güçlendirme:</strong> 1x-20x arası ses amplifikasyonu</span>
                </li>
            </ul>
        </div>
    </div>
    
    <script>
        // Global Variables
        let audioContext = null;
        let source = null;
        let gainNode = null;
        let analyser = null;
        let stream = null;
        let animationId = null;
        let isMuted = false;
        let isListening = false;
        let currentMode = 'normal';
        
        // Advanced Processors
        let advancedProcessor = null;
        let soundClassifier = null;
        let distanceEstimator = null;
        let directionDetector = null;
        let spectrogramData = [];
        let detectionMode = 'medium';
        let aiAnalysisInterval = null;
        
        // Audio Processing Nodes
        let voiceIsolationFilter = null;
        let noiseGate = null;
        let compressor = null;
        let lowShelfFilter = null;
        let highShelfFilter = null;
        let bandpassFilter = null;
        let spectralProcessor = null;
        
        // Feature States
        const features = {
            voiceIsolation: false,
            noiseReduction: false,
            speechEnhance: false,
            directionFocus: false
        };
        
        // Initialize Advanced Processors
        async function initializeAdvancedProcessors() {
            try {
                if (typeof AdvancedAudioProcessor !== 'undefined') {
                    advancedProcessor = new AdvancedAudioProcessor();
                    await advancedProcessor.initialize(96000);
                    soundClassifier = advancedProcessor.soundClassifier;
                    distanceEstimator = advancedProcessor.distanceEstimator;
                    directionDetector = advancedProcessor.directionDetector;
                } else {
                    console.warn('AdvancedAudioProcessor not loaded, using fallback');
                    // Fallback implementation
                    advancedProcessor = {
                        currentMode: 'medium',
                        soundClassifier: {
                            classify: () => ({ category: 'unknown', confidence: 0, allConfidences: {} })
                        },
                        distanceEstimator: {
                            estimateDistance: () => ({ distance: 0, confidence: 0 })
                        },
                        directionDetector: {
                            detectDirection: () => ({ angle: 0, direction: 'Center', confidence: 0 })
                        }
                    };
                    soundClassifier = advancedProcessor.soundClassifier;
                    distanceEstimator = advancedProcessor.distanceEstimator;
                    directionDetector = advancedProcessor.directionDetector;
                }
            } catch (error) {
                console.error('Error initializing advanced processors:', error);
            }
        }
        
        // Detection Modes Configuration
        const detectionModes = {
            near: { 
                name: 'Yakın (0-5m)', 
                range: [0, 5], 
                sensitivity: 2.0, 
                icon: '🎯',
                color: '#10b981'
            },
            medium: { 
                name: 'Orta (5-20m)', 
                range: [5, 20], 
                sensitivity: 1.0,
                icon: '📡',
                color: '#3b82f6'
            },
            far: { 
                name: 'Uzak (20-50m)', 
                range: [20, 50], 
                sensitivity: 0.5,
                icon: '🛰️',
                color: '#8b5cf6'
            },
            all: { 
                name: 'Tüm Sesler', 
                range: [0, 100], 
                sensitivity: 0.8,
                icon: '🌐',
                color: '#ef4444'
            },
            ai: { 
                name: 'AI Akıllı Mod', 
                range: 'adaptive', 
                sensitivity: 'auto',
                icon: '🤖',
                color: '#f59e0b'
            }
        };
        
        // Audio Processing Configuration
        const audioConfig = {
            normal: {
                lowFreq: 20,
                highFreq: 20000,
                gain: 1,
                compression: 0.5,
                noiseGate: -50
            },
            voice: {
                lowFreq: 85,
                highFreq: 8000,
                gain: 1.5,
                compression: 0.8,
                noiseGate: -45,
                presenceBoost: 3000
            },
            meeting: {
                lowFreq: 100,
                highFreq: 6000,
                gain: 1.2,
                compression: 0.9,
                noiseGate: -40,
                echoReduction: true
            },
            outdoor: {
                lowFreq: 200,
                highFreq: 5000,
                gain: 1.8,
                compression: 0.7,
                noiseGate: -35,
                windFilter: true
            },
            music: {
                lowFreq: 20,
                highFreq: 20000,
                gain: 1,
                compression: 0.3,
                noiseGate: -60
            },
            elderly: {
                lowFreq: 500,
                highFreq: 4000,
                gain: 2,
                compression: 0.9,
                noiseGate: -40,
                clarityBoost: true
            },
            medical: {
                lowFreq: 20,
                highFreq: 200,
                gain: 50, // Very high gain for weak signals
                compression: 0.95,
                noiseGate: -60,
                heartbeatMode: true
            }
        };
        
        // Medical Demo Variables and Functions
        let heartbeatDemo = null;
        let heartbeatInterval = null;
        let medicalModeAccepted = false;
        
        // Accept Medical Demo
        function acceptMedicalDemo() {
            medicalModeAccepted = true;
            document.getElementById('medicalWarning').style.display = 'none';
            document.getElementById('heartbeatDisplay').style.display = 'block';
            
            // Initialize heartbeat demo
            if (!heartbeatDemo) {
                if (typeof HeartbeatDetectionDemo !== 'undefined') {
                    heartbeatDemo = new HeartbeatDetectionDemo();
                } else {
                    console.warn('HeartbeatDetectionDemo not loaded');
                    heartbeatDemo = {
                        detectRhythmicPatterns: () => ({ bpm: 0, confidence: 0, type: { type: 'N/A' } }),
                        envelopeDetection: (data) => data,
                        generateHeartbeatVisualization: () => {}
                    };
                }
            }
            
            // Start heartbeat analysis if listening
            if (isListening) {
                startHeartbeatAnalysis();
            }
        }
        
        // Start Heartbeat Analysis
        function startHeartbeatAnalysis() {
            if (!heartbeatDemo || !analyser) return;
            
            const canvas = document.getElementById('heartbeatWaveform');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            heartbeatInterval = setInterval(() => {
                const bufferLength = analyser.frequencyBinCount;
                const timeData = new Float32Array(bufferLength);
                analyser.getFloatTimeDomainData(timeData);
                
                // Apply envelope detection
                const envelope = heartbeatDemo.envelopeDetection(timeData);
                
                // Detect rhythm
                const result = heartbeatDemo.detectRhythmicPatterns(envelope);
                
                // Update display
                document.getElementById('bpmDisplay').textContent = result.bpm || '--';
                document.getElementById('confidenceDisplay').textContent = result.confidence + '%';
                document.getElementById('bpmType').textContent = result.type ? result.type.type : 'Analiz ediliyor...';
                
                // Update visualization
                heartbeatDemo.generateHeartbeatVisualization(result.bpm, canvas);
                
                // Color coding based on BPM range
                const bpmElement = document.getElementById('bpmDisplay');
                if (result.bpm >= 120 && result.bpm <= 160) {
                    bpmElement.style.color = '#10b981'; // Green for fetal range
                } else if (result.bpm >= 60 && result.bpm <= 100) {
                    bpmElement.style.color = '#3b82f6'; // Blue for adult range
                } else {
                    bpmElement.style.color = '#f59e0b'; // Orange for unusual
                }
            }, 100); // 10 FPS for heartbeat analysis
        }
        
        // Voice Isolation Engine
        class VoiceIsolationEngine {
            constructor(context) {
                this.context = context;
                this.setupFilters();
            }
            
            setupFilters() {
                // Male voice filter (85-255 Hz fundamental)
                this.maleVoiceFilter = this.context.createBiquadFilter();
                this.maleVoiceFilter.type = 'bandpass';
                this.maleVoiceFilter.frequency.setValueAtTime(170, this.context.currentTime);
                this.maleVoiceFilter.Q.setValueAtTime(2, this.context.currentTime);
                
                // Female voice filter (165-265 Hz fundamental)
                this.femaleVoiceFilter = this.context.createBiquadFilter();
                this.femaleVoiceFilter.type = 'bandpass';
                this.femaleVoiceFilter.frequency.setValueAtTime(215, this.context.currentTime);
                this.femaleVoiceFilter.Q.setValueAtTime(2, this.context.currentTime);
                
                // Speech formant enhancement (2-4 kHz)
                this.formantFilter = this.context.createBiquadFilter();
                this.formantFilter.type = 'peaking';
                this.formantFilter.frequency.setValueAtTime(3000, this.context.currentTime);
                this.formantFilter.Q.setValueAtTime(1.5, this.context.currentTime);
                this.formantFilter.gain.setValueAtTime(6, this.context.currentTime);
                
                // Sibilance control (5-8 kHz)
                this.sibilanceFilter = this.context.createBiquadFilter();
                this.sibilanceFilter.type = 'peaking';
                this.sibilanceFilter.frequency.setValueAtTime(6500, this.context.currentTime);
                this.sibilanceFilter.Q.setValueAtTime(2, this.context.currentTime);
                this.sibilanceFilter.gain.setValueAtTime(-3, this.context.currentTime);
            }
            
            process(input) {
                // Connect filters in series
                input.connect(this.maleVoiceFilter);
                this.maleVoiceFilter.connect(this.femaleVoiceFilter);
                this.femaleVoiceFilter.connect(this.formantFilter);
                this.formantFilter.connect(this.sibilanceFilter);
                return this.sibilanceFilter;
            }
        }
        
        // Spectral Noise Reduction
        class SpectralNoiseReducer {
            constructor(context) {
                this.context = context;
                this.fftSize = 2048;
                this.smoothingFactor = 0.8;
                this.noiseProfile = new Float32Array(this.fftSize / 2);
                this.isLearning = true;
                this.learningFrames = 30;
                this.currentFrame = 0;
            }
            
            updateNoiseProfile(frequencyData) {
                if (this.isLearning) {
                    for (let i = 0; i < this.noiseProfile.length; i++) {
                        this.noiseProfile[i] = Math.max(
                            this.noiseProfile[i] * 0.95 + frequencyData[i] * 0.05,
                            -100
                        );
                    }
                    
                    this.currentFrame++;
                    if (this.currentFrame >= this.learningFrames) {
                        this.isLearning = false;
                    }
                }
            }
            
            processSpectrum(frequencyData) {
                const processed = new Float32Array(frequencyData.length);
                
                for (let i = 0; i < frequencyData.length; i++) {
                    const signalPower = Math.pow(10, frequencyData[i] / 20);
                    const noisePower = Math.pow(10, this.noiseProfile[i] / 20);
                    
                    // Spectral subtraction with over-subtraction factor
                    const cleanPower = Math.max(
                        signalPower - 2 * noisePower,
                        0.1 * signalPower
                    );
                    
                    processed[i] = 20 * Math.log10(cleanPower);
                }
                
                return processed;
            }
        }
        
        // Initialize Audio System
        async function initializeAudioSystem() {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
                
                // Check if context is suspended (iOS requirement)
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                return true;
            } catch (error) {
                console.error('Audio system initialization failed:', error);
                return false;
            }
        }
        
        // Set Processing Mode
        function setMode(mode) {
            currentMode = mode;
            
            // Update UI
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
            
            // Show advanced panel for voice-related modes
            const advancedPanel = document.getElementById('advancedPanel');
            if (['voice', 'meeting', 'elderly'].includes(mode)) {
                advancedPanel.classList.add('show');
            } else {
                advancedPanel.classList.remove('show');
            }
            
            // Handle medical demo mode
            if (mode === 'medical') {
                document.getElementById('medicalWarning').style.display = 'block';
                document.getElementById('aiCategories').parentElement.style.display = 'none';
                if (medicalModeAccepted) {
                    document.getElementById('heartbeatDisplay').style.display = 'block';
                    if (isListening) {
                        startHeartbeatAnalysis();
                    }
                }
            } else {
                document.getElementById('medicalWarning').style.display = 'none';
                document.getElementById('heartbeatDisplay').style.display = 'none';
                document.getElementById('aiCategories').parentElement.style.display = 'block';
                if (heartbeatInterval) {
                    clearInterval(heartbeatInterval);
                    heartbeatInterval = null;
                }
            }
            
            // Apply mode configuration if listening
            if (isListening && audioContext) {
                applyModeConfiguration();
            }
            
            updateStatus(`📡 Mod değiştirildi: ${getModeDisplayName(mode)}`, 'warning');
        }
        
        // Get Mode Display Name
        function getModeDisplayName(mode) {
            const names = {
                normal: 'Normal Dinleme',
                voice: 'Konuşma Odaklı',
                meeting: 'Toplantı Modu',
                outdoor: 'Dış Mekan',
                music: 'Müzik',
                elderly: 'Yaşlı Dostu',
                medical: 'Kalp Atışı Demo (Eğitsel)'
            };
            return names[mode] || mode;
        }
        
        // Apply Mode Configuration
        function applyModeConfiguration() {
            if (!audioContext || !source) return;
            
            const config = audioConfig[currentMode];
            
            // Update filters based on mode
            if (bandpassFilter) {
                const centerFreq = Math.sqrt(config.lowFreq * config.highFreq);
                bandpassFilter.frequency.setValueAtTime(centerFreq, audioContext.currentTime);
                bandpassFilter.Q.setValueAtTime(
                    centerFreq / (config.highFreq - config.lowFreq),
                    audioContext.currentTime
                );
            }
            
            // Update compressor
            if (compressor) {
                const ratio = 1 + (config.compression * 11); // 1:1 to 12:1
                compressor.ratio.setValueAtTime(ratio, audioContext.currentTime);
                compressor.threshold.setValueAtTime(-20, audioContext.currentTime);
            }
            
            // Update noise gate
            if (noiseGate) {
                noiseGate.threshold.setValueAtTime(config.noiseGate, audioContext.currentTime);
            }
            
            // Special mode features
            if (config.presenceBoost && highShelfFilter) {
                highShelfFilter.frequency.setValueAtTime(config.presenceBoost, audioContext.currentTime);
                highShelfFilter.gain.setValueAtTime(6, audioContext.currentTime);
            }
            
            if (config.clarityBoost && highShelfFilter) {
                highShelfFilter.frequency.setValueAtTime(2500, audioContext.currentTime);
                highShelfFilter.gain.setValueAtTime(8, audioContext.currentTime);
            }
        }
        
        // Toggle Feature
        function toggleFeature(featureName) {
            features[featureName] = !features[featureName];
            
            // Update UI
            const card = document.getElementById(featureName);
            if (features[featureName]) {
                card.classList.add('active');
            } else {
                card.classList.remove('active');
            }
            
            // Apply feature changes if listening
            if (isListening && audioContext) {
                reconfigureAudioChain();
            }
            
            updateStatus(`⚙️ ${getFeatureDisplayName(featureName)}: ${features[featureName] ? 'Açık' : 'Kapalı'}`, 'warning');
        }
        
        // Get Feature Display Name
        function getFeatureDisplayName(feature) {
            const names = {
                voiceIsolation: 'Ses İzolasyonu',
                noiseReduction: 'Gürültü Azaltma',
                speechEnhance: 'Konuşma Netleştirme',
                directionFocus: 'Yön Odaklama'
            };
            return names[feature] || feature;
        }
        
        // Set Detection Mode
        function setDetectionMode(mode) {
            detectionMode = mode;
            
            // Update UI
            document.querySelectorAll('.detection-mode-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = '#e5e7eb';
                btn.style.color = '#374151';
            });
            
            const activeBtn = document.querySelector(`.detection-mode-btn[data-mode="${mode}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
                const modeConfig = detectionModes[mode];
                if (modeConfig) {
                    activeBtn.style.background = modeConfig.color;
                    activeBtn.style.color = 'white';
                }
            }
            
            // Apply detection mode settings
            if (isListening && advancedProcessor) {
                applyDetectionMode();
            }
            
            if (detectionModes[mode]) {
                updateStatus(`🎯 Algılama modu: ${detectionModes[mode].name}`, 'warning');
            }
        }
        
        // Apply Detection Mode Settings
        function applyDetectionMode() {
            if (!advancedProcessor) return;
            
            const mode = detectionModes[detectionMode];
            
            // Adjust sensitivity
            if (gainNode) {
                const baseGain = parseFloat(document.getElementById('volumeSlider').value);
                gainNode.gain.value = baseGain * mode.sensitivity;
            }
            
            // Update processor settings
            advancedProcessor.currentMode = detectionMode;
        }
        
        // AI Analysis Function
        async function performAIAnalysis() {
            if (!analyser || !soundClassifier || !distanceEstimator || !directionDetector) return;
            
            const bufferLength = analyser.frequencyBinCount;
            const frequencyData = new Uint8Array(bufferLength);
            const timeData = new Float32Array(bufferLength);
            
            analyser.getByteFrequencyData(frequencyData);
            analyser.getFloatTimeDomainData(timeData);
            
            // Sound Classification
            const classification = soundClassifier.classify(frequencyData, timeData);
            updateAICategories(classification);
            
            // Distance Estimation
            const distance = distanceEstimator.estimateDistance(frequencyData, timeData);
            document.getElementById('distanceValue').textContent = `${distance.distance}m`;
            
            // Direction Detection (simplified for mono input)
            const direction = directionDetector.detectDirection(timeData, timeData);
            document.getElementById('directionValue').textContent = `${direction.angle}°`;
            
            // Update status based on detection
            if (classification.confidence > 70) {
                const emoji = getEmojiForCategory(classification.category);
                updateStatus(`${emoji} Algılandı: ${classification.category} (${Math.round(classification.confidence)}%)`, 'active');
            }
        }
        
        // Update AI Categories Display
        function updateAICategories(classification) {
            const categories = classification.allConfidences;
            
            Object.entries(categories).forEach(([category, data]) => {
                const element = document.querySelector(`[data-category="${category}"]`);
                if (element) {
                    const confidence = data.confidence || 0;
                    const bar = element.querySelector('.confidence-bar');
                    
                    if (bar) {
                        bar.style.width = `${confidence}%`;
                    }
                    
                    if (confidence > 50) {
                        element.classList.add('active');
                    } else {
                        element.classList.remove('active');
                    }
                }
            });
        }
        
        // Get Emoji for Category
        function getEmojiForCategory(category) {
            const emojis = {
                human: '👤',
                animal: '🐾',
                vehicle: '🚗',
                nature: '🌿',
                music: '🎵',
                emergency: '🚨',
                mechanical: '⚙️',
                electronic: '📱',
                unknown: '❓'
            };
            return emojis[category] || emojis.unknown;
        }
        
        // Quick Start
        async function quickStart() {
            showLoading(true);
            
            try {
                // Initialize advanced processors
                await initializeAdvancedProcessors();
                
                // Initialize audio system
                const initialized = await initializeAudioSystem();
                if (!initialized) {
                    throw new Error('Ses sistemi başlatılamadı');
                }
                
                // Request microphone permission
                await requestMicrophonePermission();
                
                // Start listening if permission granted
                if (document.getElementById('startBtn').disabled === false) {
                    await startListening();
                }
            } catch (error) {
                console.error('Quick start error:', error);
                showError('Başlatma hatası: ' + error.message);
            } finally {
                showLoading(false);
            }
        }
        
        // Request Microphone Permission
        async function requestMicrophonePermission() {
            try {
                updateStatus('🎤 Mikrofon izni isteniyor...', 'warning');
                
                const constraints = {
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 48000,
                        channelCount: 2
                    }
                };
                
                // Test microphone access
                const testStream = await navigator.mediaDevices.getUserMedia(constraints);
                testStream.getTracks().forEach(track => track.stop());
                
                // Permission granted
                showPermissionSuccess();
                
            } catch (error) {
                console.error('Microphone permission error:', error);
                handlePermissionError(error);
                throw error;
            }
        }
        
        // Show Permission Success
        function showPermissionSuccess() {
            const permissionCard = document.getElementById('permissionCard');
            permissionCard.className = 'permission-card success show';
            document.getElementById('permissionText').innerHTML = 
                '<strong>✅ Mikrofon izni verildi!</strong><br>Artık dinlemeyi başlatabilirsiniz.';
            
            document.getElementById('startBtn').disabled = false;
            updateStatus('✅ Hazır - Dinlemeyi başlatın', 'idle');
            
            setTimeout(() => {
                permissionCard.classList.remove('show');
            }, 3000);
        }
        
        // Handle Permission Error
        function handlePermissionError(error) {
            const permissionCard = document.getElementById('permissionCard');
            permissionCard.className = 'permission-card error show';
            
            let errorMessage = '';
            if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                errorMessage = '<strong>❌ İzin reddedildi</strong><br>Tarayıcı ayarlarından mikrofon iznini verin';
            } else if (error.name === 'NotFoundError') {
                errorMessage = '<strong>❌ Mikrofon bulunamadı</strong><br>Cihazınızda mikrofon var mı?';
            } else if (error.name === 'NotReadableError') {
                errorMessage = '<strong>❌ Mikrofon kullanımda</strong><br>Başka uygulamaları kapatın';
            } else {
                errorMessage = '<strong>❌ Hata:</strong> ' + error.message;
            }
            
            document.getElementById('permissionText').innerHTML = errorMessage;
        }
        
        // Setup Audio Chain
        function setupAudioChain() {
            if (!audioContext || !source) return;
            
            let currentNode = source;
            
            // Voice Isolation (if enabled)
            if (features.voiceIsolation) {
                const voiceIsolator = new VoiceIsolationEngine(audioContext);
                currentNode = voiceIsolator.process(currentNode);
            }
            
            // Bandpass Filter (mode-specific)
            bandpassFilter = audioContext.createBiquadFilter();
            bandpassFilter.type = 'bandpass';
            const config = audioConfig[currentMode];
            const centerFreq = Math.sqrt(config.lowFreq * config.highFreq);
            bandpassFilter.frequency.setValueAtTime(centerFreq, audioContext.currentTime);
            bandpassFilter.Q.setValueAtTime(
                centerFreq / (config.highFreq - config.lowFreq),
                audioContext.currentTime
            );
            
            if (!features.voiceIsolation) {
                currentNode.connect(bandpassFilter);
                currentNode = bandpassFilter;
            }
            
            // Low Shelf Filter (bass control)
            if (document.getElementById('enhancerToggle').checked) {
                lowShelfFilter = audioContext.createBiquadFilter();
                lowShelfFilter.type = 'lowshelf';
                lowShelfFilter.frequency.setValueAtTime(320, audioContext.currentTime);
                lowShelfFilter.gain.setValueAtTime(3, audioContext.currentTime);
                
                currentNode.connect(lowShelfFilter);
                currentNode = lowShelfFilter;
            }
            
            // High Shelf Filter (treble control)
            if (features.speechEnhance || document.getElementById('enhancerToggle').checked) {
                highShelfFilter = audioContext.createBiquadFilter();
                highShelfFilter.type = 'highshelf';
                highShelfFilter.frequency.setValueAtTime(3200, audioContext.currentTime);
                highShelfFilter.gain.setValueAtTime(features.speechEnhance ? 6 : 3, audioContext.currentTime);
                
                currentNode.connect(highShelfFilter);
                currentNode = highShelfFilter;
            }
            
            // Noise Gate (for noise reduction)
            if (features.noiseReduction) {
                noiseGate = audioContext.createDynamicsCompressor();
                noiseGate.threshold.setValueAtTime(-45, audioContext.currentTime);
                noiseGate.knee.setValueAtTime(8, audioContext.currentTime);
                noiseGate.ratio.setValueAtTime(10, audioContext.currentTime);
                noiseGate.attack.setValueAtTime(0.001, audioContext.currentTime);
                noiseGate.release.setValueAtTime(0.1, audioContext.currentTime);
                
                currentNode.connect(noiseGate);
                currentNode = noiseGate;
            }
            
            // Compressor
            if (document.getElementById('compressorToggle').checked) {
                compressor = audioContext.createDynamicsCompressor();
                compressor.threshold.setValueAtTime(-20, audioContext.currentTime);
                compressor.knee.setValueAtTime(10, audioContext.currentTime);
                compressor.ratio.setValueAtTime(4, audioContext.currentTime);
                compressor.attack.setValueAtTime(0.003, audioContext.currentTime);
                compressor.release.setValueAtTime(0.1, audioContext.currentTime);
                
                currentNode.connect(compressor);
                currentNode = compressor;
            }
            
            // Gain Node
            gainNode = audioContext.createGain();
            gainNode.gain.value = isMuted ? 0 : document.getElementById('volumeSlider').value;
            currentNode.connect(gainNode);
            
            // Analyser
            analyser = audioContext.createAnalyser();
            analyser.fftSize = document.getElementById('batterySaverToggle').checked ? 1024 : 2048;
            analyser.smoothingTimeConstant = 0.8;
            gainNode.connect(analyser);
            
            // Connect to output
            gainNode.connect(audioContext.destination);
            
            // Apply mode configuration
            applyModeConfiguration();
        }
        
        // Reconfigure Audio Chain
        function reconfigureAudioChain() {
            if (!audioContext || !source) return;
            
            // Disconnect all nodes
            source.disconnect();
            if (bandpassFilter) bandpassFilter.disconnect();
            if (lowShelfFilter) lowShelfFilter.disconnect();
            if (highShelfFilter) highShelfFilter.disconnect();
            if (noiseGate) noiseGate.disconnect();
            if (compressor) compressor.disconnect();
            if (gainNode) gainNode.disconnect();
            if (analyser) analyser.disconnect();
            
            // Reconnect with new configuration
            setupAudioChain();
        }
        
        // Start Listening
        async function startListening() {
            if (isListening) return;
            
            try {
                showLoading(true);
                updateStatus('🎤 Mikrofon başlatılıyor...', 'warning');
                
                // Initialize audio context if needed
                if (!audioContext) {
                    const initialized = await initializeAudioSystem();
                    if (!initialized) {
                        throw new Error('Ses sistemi başlatılamadı');
                    }
                }
                
                // Get microphone stream
                const constraints = {
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: document.getElementById('lowLatencyToggle').checked ? 48000 : 44100,
                        channelCount: 2
                    }
                };
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Create source
                source = audioContext.createMediaStreamSource(stream);
                
                // Setup audio chain
                setupAudioChain();
                
                // Update UI
                isListening = true;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('muteBtn').disabled = false;
                document.getElementById('liveBadge').style.display = 'inline-block';
                
                updateStatus('🎧 Canlı dinleme aktif', 'active');
                
                // Start visualization
                startVisualization();
                
                // Start real-time indicators
                startIndicators();
                
                // Start AI analysis or heartbeat analysis based on mode
                if (currentMode === 'medical') {
                    if (medicalModeAccepted) {
                        startHeartbeatAnalysis();
                    }
                } else {
                    aiAnalysisInterval = setInterval(performAIAnalysis, 50); // 20 FPS
                }
                
            } catch (error) {
                console.error('Start listening error:', error);
                showError('Dinleme başlatılamadı: ' + error.message);
                
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }
            } finally {
                showLoading(false);
            }
        }
        
        // Stop Listening
        function stopListening() {
            if (!isListening) return;
            
            // Stop animation
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Stop stream
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            // Disconnect nodes
            if (source) {
                source.disconnect();
                source = null;
            }
            
            // Close audio context
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            
            // Reset variables
            bandpassFilter = null;
            lowShelfFilter = null;
            highShelfFilter = null;
            noiseGate = null;
            compressor = null;
            gainNode = null;
            analyser = null;
            isListening = false;
            isMuted = false;
            
            // Update UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('muteBtn').disabled = true;
            document.getElementById('liveBadge').style.display = 'none';
            document.getElementById('muteBtn').innerHTML = '<span>🔇</span><span>Sessiz</span>';
            
            updateStatus('⏹️ Dinleme durduruldu', 'idle');
            
            // Clear visualizer
            const canvas = document.getElementById('visualizer');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Stop AI analysis
            if (aiAnalysisInterval) {
                clearInterval(aiAnalysisInterval);
                aiAnalysisInterval = null;
            }
            
            // Stop heartbeat analysis
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
            
            // Reset indicators
            document.getElementById('clarityValue').textContent = '0%';
            document.getElementById('distanceValue').textContent = '0m';
            document.getElementById('directionValue').textContent = '0°';
            document.getElementById('gainValue').textContent = '1x';
            
            // Reset AI categories
            document.querySelectorAll('.ai-category').forEach(cat => {
                cat.classList.remove('active');
                const bar = cat.querySelector('.confidence-bar');
                if (bar) bar.style.width = '0%';
            });
        }
        
        // Toggle Mute
        function toggleMute() {
            if (!gainNode) return;
            
            isMuted = !isMuted;
            
            if (isMuted) {
                gainNode.gain.value = 0;
                document.getElementById('muteBtn').innerHTML = '<span>🔊</span><span>Sesi Aç</span>';
                updateStatus('🔇 Ses kapatıldı', 'warning');
            } else {
                gainNode.gain.value = document.getElementById('volumeSlider').value;
                document.getElementById('muteBtn').innerHTML = '<span>🔇</span><span>Sessiz</span>';
                updateStatus('🎧 Canlı dinleme aktif', 'active');
            }
        }
        
        // Update Volume with 500x max
        function updateVolume(value) {
            const displayValue = value > 100 ? `${value}x 🔥` : `${value}x`;
            document.getElementById('volumeValue').textContent = displayValue;
            document.getElementById('gainValue').textContent = displayValue;
            
            if (gainNode && !isMuted) {
                gainNode.gain.value = value;
            }
        }
        
        // Start Visualization
        function startVisualization() {
            if (!analyser) return;
            
            const canvas = document.getElementById('visualizer');
            const ctx = canvas.getContext('2d');
            
            // Setup canvas
            const setupCanvas = () => {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            };
            
            setupCanvas();
            window.addEventListener('resize', setupCanvas);
            
            // Initialize advanced visualizations
            initializeSpectrogram();
            initialize3DSoundMap();
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            function draw() {
                if (!isListening) return;
                
                animationId = requestAnimationFrame(draw);
                
                analyser.getByteFrequencyData(dataArray);
                
                const width = canvas.width / window.devicePixelRatio;
                const height = canvas.height / window.devicePixelRatio;
                
                // Background
                ctx.fillStyle = '#1e293b';
                ctx.fillRect(0, 0, width, height);
                
                // Draw frequency bars
                const barWidth = (width / bufferLength) * 2.5;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * height;
                    
                    // Color based on frequency range
                    let color;
                    if (i < bufferLength * 0.1) {
                        // Bass (red)
                        color = `hsl(0, 80%, ${50 + (dataArray[i] / 255) * 30}%)`;
                    } else if (i < bufferLength * 0.3) {
                        // Mid-bass (orange)
                        color = `hsl(30, 80%, ${50 + (dataArray[i] / 255) * 30}%)`;
                    } else if (i < bufferLength * 0.5) {
                        // Midrange (yellow)
                        color = `hsl(60, 80%, ${50 + (dataArray[i] / 255) * 30}%)`;
                    } else if (i < bufferLength * 0.7) {
                        // Upper-mid (green)
                        color = `hsl(120, 80%, ${50 + (dataArray[i] / 255) * 30}%)`;
                    } else {
                        // Treble (blue)
                        color = `hsl(200, 80%, ${50 + (dataArray[i] / 255) * 30}%)`;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                    
                    x += barWidth + 1;
                    if (x > width) break;
                }
                
                // Update frequency display
                const maxFreq = (audioContext.sampleRate / 2) * (bufferLength / analyser.fftSize);
                document.getElementById('frequencyDisplay').textContent = 
                    `20Hz - ${(maxFreq / 1000).toFixed(1)}kHz`;
                
                // Update advanced visualizations
                updateSpectrogram(dataArray);
                update3DSoundMap(dataArray);
            }
            
            draw();
        }
        
        // Initialize Spectrogram
        function initializeSpectrogram() {
            const canvas = document.getElementById('spectrogram');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // Clear with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0f172a');
            gradient.addColorStop(1, '#1e293b');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Initialize data array
            spectrogramData = [];
        }
        
        // Update Spectrogram
        function updateSpectrogram(frequencyData) {
            const canvas = document.getElementById('spectrogram');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Add new data
            spectrogramData.push([...frequencyData]);
            
            // Keep last 100 frames
            if (spectrogramData.length > 100) {
                spectrogramData.shift();
            }
            
            // Clear canvas
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            // Draw spectrogram
            const columnWidth = width / spectrogramData.length;
            
            spectrogramData.forEach((data, timeIndex) => {
                const x = timeIndex * columnWidth;
                const binHeight = height / data.length;
                
                data.forEach((value, freqIndex) => {
                    const y = height - (freqIndex * binHeight) - binHeight;
                    const intensity = value / 255;
                    
                    // Color mapping
                    const hue = 240 - (intensity * 240); // Blue to red
                    const lightness = 20 + (intensity * 60);
                    
                    ctx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
                    ctx.fillRect(x, y, columnWidth, binHeight);
                });
            });
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 0.5;
            
            // Frequency lines
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }
        
        // Initialize 3D Sound Map
        function initialize3DSoundMap() {
            const canvas = document.getElementById('soundMap3D');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // Draw initial compass
            draw3DCompass(ctx, canvas.width, canvas.height);
        }
        
        // Update 3D Sound Map
        function update3DSoundMap(frequencyData) {
            const canvas = document.getElementById('soundMap3D');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Clear with fade effect
            ctx.fillStyle = 'rgba(15, 23, 42, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            // Redraw compass
            draw3DCompass(ctx, width, height);
            
            // Analyze sound direction (simplified)
            const leftChannel = frequencyData.slice(0, frequencyData.length / 2);
            const rightChannel = frequencyData.slice(frequencyData.length / 2);
            
            const leftEnergy = leftChannel.reduce((a, b) => a + b, 0) / leftChannel.length;
            const rightEnergy = rightChannel.reduce((a, b) => a + b, 0) / rightChannel.length;
            
            const direction = Math.atan2(rightEnergy - leftEnergy, 100) * 180 / Math.PI;
            const distance = Math.sqrt(leftEnergy + rightEnergy) / 10;
            
            // Draw sound source
            const angle = (direction - 90) * Math.PI / 180;
            const x = centerX + Math.cos(angle) * distance;
            const y = centerY + Math.sin(angle) * distance;
            
            // Glow effect
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, 20);
            gradient.addColorStop(0, 'rgba(139, 92, 246, 0.8)');
            gradient.addColorStop(1, 'rgba(139, 92, 246, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, Math.PI * 2);
            ctx.fill();
            
            // Center dot
            ctx.fillStyle = '#8b5cf6';
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw 3D Compass
        function draw3DCompass(ctx, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.4;
            
            // Outer circle
            ctx.strokeStyle = 'rgba(139, 92, 246, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner circles
            for (let r = radius * 0.75; r > 0; r -= radius * 0.25) {
                ctx.strokeStyle = 'rgba(139, 92, 246, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Direction lines
            ctx.strokeStyle = 'rgba(139, 92, 246, 0.2)';
            ctx.lineWidth = 1;
            
            for (let angle = 0; angle < 360; angle += 45) {
                const rad = angle * Math.PI / 180;
                const x1 = centerX + Math.cos(rad) * radius * 0.9;
                const y1 = centerY + Math.sin(rad) * radius * 0.9;
                const x2 = centerX + Math.cos(rad) * radius;
                const y2 = centerY + Math.sin(rad) * radius;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // Direction labels
            ctx.fillStyle = 'rgba(139, 92, 246, 0.6)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            ctx.fillText('N', centerX, centerY - radius - 10);
            ctx.fillText('S', centerX, centerY + radius + 10);
            ctx.fillText('E', centerX + radius + 10, centerY);
            ctx.fillText('W', centerX - radius - 10, centerY);
            
            // Center point
            ctx.fillStyle = '#8b5cf6';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Start Real-time Indicators
        function startIndicators() {
            if (!analyser) return;
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const spectralProcessor = new SpectralNoiseReducer(audioContext);
            
            function updateIndicators() {
                if (!isListening) return;
                
                analyser.getByteFrequencyData(dataArray);
                
                // Calculate clarity (based on speech frequencies prominence)
                let speechEnergy = 0;
                let totalEnergy = 0;
                const speechStartBin = Math.floor(300 * bufferLength / (audioContext.sampleRate / 2));
                const speechEndBin = Math.floor(3400 * bufferLength / (audioContext.sampleRate / 2));
                
                for (let i = 0; i < bufferLength; i++) {
                    const energy = dataArray[i] / 255;
                    totalEnergy += energy;
                    
                    if (i >= speechStartBin && i <= speechEndBin) {
                        speechEnergy += energy;
                    }
                }
                
                const clarity = totalEnergy > 0 ? 
                    Math.round((speechEnergy / totalEnergy) * 100) : 0;
                document.getElementById('clarityValue').textContent = clarity + '%';
                
                // Calculate noise level
                spectralProcessor.updateNoiseProfile(dataArray);
                const avgNoise = dataArray.reduce((a, b) => a + b, 0) / bufferLength;
                const noiseDb = Math.round(20 * Math.log10(avgNoise / 255));
                document.getElementById('noiseValue').textContent = noiseDb + 'dB';
                
                // Update gain display
                const currentGain = document.getElementById('volumeSlider').value;
                document.getElementById('gainValue').textContent = currentGain + 'x';
                
                setTimeout(updateIndicators, 100);
            }
            
            updateIndicators();
        }
        
        // Update Status
        function updateStatus(text, type) {
            const statusBar = document.getElementById('statusBar');
            statusBar.textContent = text;
            statusBar.className = 'status-bar status-' + type;
        }
        
        // Show Loading
        function showLoading(show) {
            const overlay = document.getElementById('loadingOverlay');
            if (show) {
                overlay.classList.add('show');
            } else {
                overlay.classList.remove('show');
            }
        }
        
        // Show Error
        function showError(message) {
            updateStatus('❌ ' + message, 'error');
        }
        
        // Settings Event Listeners
        document.getElementById('compressorToggle').addEventListener('change', () => {
            if (isListening) reconfigureAudioChain();
        });
        
        document.getElementById('enhancerToggle').addEventListener('change', () => {
            if (isListening) reconfigureAudioChain();
        });
        
        document.getElementById('lowLatencyToggle').addEventListener('change', () => {
            if (isListening) {
                stopListening();
                setTimeout(startListening, 100);
            }
        });
        
        document.getElementById('batterySaverToggle').addEventListener('change', (e) => {
            if (analyser) {
                analyser.fftSize = e.target.checked ? 1024 : 2048;
            }
        });
        
        // Page Load
        window.addEventListener('DOMContentLoaded', () => {
            // Check browser compatibility
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                const permissionCard = document.getElementById('permissionCard');
                permissionCard.className = 'permission-card error show';
                document.getElementById('permissionText').innerHTML = 
                    '<strong>❌ Desteklenmiyor</strong><br>Tarayıcınız mikrofon erişimini desteklemiyor';
                return;
            }
            
            // Check for HTTPS
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                updateStatus('⚠️ HTTPS bağlantısı gerekli - Mikrofon çalışmayabilir', 'warning');
            }
            
            // iOS touch event for audio context
            if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
                document.addEventListener('touchstart', function() {
                    if (audioContext && audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                }, { once: true });
            }
        });
        
        // Page Visibility
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isListening) {
                console.log('Page hidden - audio continues in background');
            }
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (isListening) {
                stopListening();
            }
        });
    </script>
</body>
</html>